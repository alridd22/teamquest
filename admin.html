<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#2A1F18" />
  <title>TeamQuest - Command Centre</title>

  <style>
    :root{
      --bg:url("/TQ%20Web%20extended%20background-100.jpg");
      --ink:#2E2114; --ink-soft:#6A5A47;
      --parchment:#F7EED8; --parchment-2:#F3E6CF; --paper:#FFFDF8;
      --gold:#F0C433; --gold-deep:#A7711F;
      --ok:#1F6E38; --okbg:#CFF2DA; --err:#B42318;
      --nav-h:64px; --gutter:22px;
      --radius-card:22px; --radius-sm:14px;
      --shadow-card:0 18px 40px rgba(0,0,0,.35);
      --shadow-soft:0 6px 18px rgba(0,0,0,.12);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--ink);
      font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
      background:linear-gradient(180deg, rgba(0,0,0,.24), rgba(0,0,0,.45)), var(--bg);
      background-size:cover; background-position:top center; background-attachment:fixed;
      -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
      padding-top:var(--nav-h);
    }

    /* NAV */
    .treasure-nav{
      position:fixed; top:0; left:0; right:0; z-index:1000; height:var(--nav-h);
      backdrop-filter:saturate(120%) blur(6px);
      background:linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,.15));
      border-bottom:1px solid rgba(255,255,255,.18);
    }
    .nav-container{height:100%; padding:0 12px; display:flex; align-items:center; justify-content:space-between; max-width:1000px; margin:0 auto}
    .nav-logo img{height:40px; width:auto; display:block; filter:drop-shadow(0 3px 10px rgba(0,0,0,.5))}
    .nav-toggle{background:none;border:none;color:#F7EED8;font-size:1.6rem;cursor:pointer}
    .nav-menu{
      position:fixed; top:var(--nav-h); left:-100%; width:100%; height:calc(100vh - var(--nav-h));
      background:linear-gradient(180deg, rgba(0,0,0,.85), rgba(0,0,0,.72));
      display:flex; flex-direction:column; align-items:center; gap:14px; padding:18px 14px; transition:left .25s;
    }
    .nav-menu.active{left:0}
    .nav-link,.dropdown-link{
      display:block; width:92%; max-width:360px; text-align:center; text-decoration:none; color:#F7EED8; font-weight:900;
      padding:12px 14px; border-radius:14px; background:rgba(247,238,216,.22); border:1px solid rgba(255,255,255,.3)
    }
    .nav-link:hover,.dropdown-link:hover{ background:rgba(247,238,216,.32) }

    /* HERO */
    .hero{min-height:220px; display:flex; flex-direction:column; align-items:center; justify-content:flex-end; padding:24px var(--gutter) 18px; text-align:center}
    .brand-logo{width:min(220px,68vw); height:auto; margin-bottom:8px; filter: drop-shadow(0 2px 0 rgba(0,0,0,.25)) drop-shadow(0 10px 24px rgba(0,0,0,.35))}
    .hero-title{font-weight:900; font-size:22px; color:#F7EED8; letter-spacing:.2px; text-shadow:0 2px 6px rgba(0,0,0,.6)}

    /* LAYOUT */
    .stack{ padding:0 var(--gutter) 28px; }
    .grid{ display:grid; grid-template-columns:1fr; gap:18px; max-width:1200px; margin:0 auto; }
    @media (min-width:980px){ .grid{ grid-template-columns:480px 1fr; } }

    /* CARDS */
    .card{
      background:var(--parchment);
      border-radius:var(--radius-card);
      box-shadow:var(--shadow-card);
      padding:18px 16px;
      border:1px solid rgba(0,0,0,.06);
    }
    h2.section-title{margin:0 0 10px; font-weight:900; color:var(--ink); display:flex; align-items:center; gap:8px}

    /* TIMER + STATUS */
    #timer{
      background:linear-gradient(180deg,#fff8ea,#fdeac7);
      border:3px solid var(--gold-deep);
      border-radius:18px;
      text-align:center;
      color:#5b3a12;
      font-weight:900;
      font-size:40px;
      letter-spacing:.12em;
      padding:22px 12px;
    }
    .status{margin-top:12px; display:flex; justify-content:center}
    .pill{
      padding:6px 12px; border-radius:999px; font-size:13px; font-weight:800; display:inline-block; border:2px solid #e3d3c2; background:#fffdf8; color:#5e4b35;
    }
    .pill.running{background:#e6fbf1; color:#106a3e; border-color:#b8efcf}
    .pill.paused{background:#fff6e9; color:#7a5a13; border-color:#f1d093}
    .pill.ended{background:#fdeeee; color:#8b1f1f; border-color:#f1b3b3}
    .pill.published{background:#e7f9ef; color:#0f6e44; border-color:#b7ebcf}

    /* BUTTONS */
    button{appearance:none; border:0; border-radius:12px; padding:12px 14px; font-weight:900; font-size:15px; cursor:pointer; box-shadow:0 2px 0 rgba(0,0,0,.08), inset 0 -2px 0 rgba(0,0,0,.08)}
    .btn{background:linear-gradient(90deg,#FDBA2D,#F0C433); color:#442812; border:3px solid var(--gold-deep)}
    .btn.pause{background:#fff6e9; border:3px solid #f3d49c; color:#6b4b0a}
    .btn.end{background:#ffe9e9; border:3px solid #f5b1b1; color:#7d2323}
    .btn.reset{background:#f7efe7; border:3px solid #dfd1c2; color:#4e3b25}
    .btn.publish{background:#e6fff2; border:3px solid #bfeeda; color:#0d6a40}
    .btn.secondary{background:#fffdf8; border:3px solid #e5d5c4; color:#3b2d16}
    .btn.final{background:#fffdf8; border:3px solid #d9c5a9; color:#3b2d16}
    .btn:disabled{opacity:.55; cursor:not-allowed}
    .grid2{display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:14px}
    .grid1{display:grid; grid-template-columns:1fr; gap:10px; margin-top:12px}

    /* STATS */
    .stats{display:grid; grid-template-columns: repeat(3,1fr); gap:12px; margin-top:16px}
    .stat{
      background:var(--paper); border:1px solid #ecdac7; border-radius:16px;
      text-align:center; padding:14px 12px; box-shadow:var(--shadow-soft);
      display:flex; flex-direction:column; align-items:center;
    }
    .stat small{display:block; opacity:.8; color:#6A5A47; line-height:1.1; min-height:2.4em}
    .stat h3{margin:6px 0 0; font-size:28px; color:#5b3a12; line-height:1}

    /* TEAM LIST */
    .teams{max-height:640px; overflow:auto; padding-right:6px}
    .team{background:var(--paper); border:1px solid #ecdac7; border-radius:16px; padding:12px; margin-bottom:12px; box-shadow:var(--shadow-soft)}
    .team.returned{opacity:.8}
    .row1{display:flex; justify-content:space-between; gap:12px; align-items:center}
    .meta{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:6px}
    .tag{font-size:12px; font-weight:800; padding:4px 8px; border-radius:999px; border:1px solid #d7c8b6; background:#f9f4ee; color:#5e4b35}

    /* Rank + Points pill with a small star */
    .team-points{
      display:inline-flex; align-items:center; gap:6px;
      font-weight:900; color:#4a351e;
      border:2px solid #d9c5a9; background:#fffdf8;
      padding:4px 8px; border-radius:10px; min-width:64px; justify-content:center;
    }
    .team-points .star{ width:14px; height:14px; }
    .team-rank{
      font-weight:900; color:#3b2d16; background:#f6e7c9; border:2px solid #d9c5a9;
      border-radius:10px; padding:4px 8px; min-width:40px; text-align:center;
    }
    .team-row-points{ display:flex; align-items:center; gap:8px; }
  </style>
</head>
<body>
  <!-- NAV -->
  <nav class="treasure-nav" id="treasure-nav">
    <div class="nav-container">
      <a href="https://theteamquest.netlify.app/" class="nav-logo" aria-label="TeamQuest Home">
        <img src="/Team%20Quest%20Logo-01.png" alt="TeamQuest Logo">
      </a>
      <button class="nav-toggle" id="nav-toggle" aria-label="Toggle menu">‚ò∞</button>
    </div>
    <ul class="nav-menu" id="nav-menu" role="menu">
      <li><a href="https://theteamquest.netlify.app/clue_hunt" class="nav-link" role="menuitem">üíé The Treasure Hunt</a></li>
      <li><a href="https://theteamquest.netlify.app/scavenger" class="nav-link" role="menuitem">üîç The Scavenger Hunt</a></li>
      <li><a href="https://theteamquest.netlify.app/quiz" class="nav-link" role="menuitem">‚è∞ The Timed Quiz</a></li>
      <li><a href="https://theteamquest.netlify.app/limerick" class="nav-link" role="menuitem">üìù The Limerick Challenge</a></li>
      <li><a href="https://theteamquest.netlify.app/kindness" class="nav-link" role="menuitem">üíñ Kindness</a></li>
      <li><a href="https://theteamquest.netlify.app/leaderboard" class="dropdown-link" role="menuitem">üèÜ The Leaderboard</a></li>
      <li><a href="https://theteamquest.netlify.app/gallery" class="dropdown-link" role="menuitem">üì∏ The Gallery</a></li>
    </ul>
  </nav>

  <!-- HERO -->
  <header class="hero">
    <img src="/Team%20Quest%20Logo-01.png" alt="TeamQuest" class="brand-logo" width="640" height="480">
    <div class="hero-title">Command Centre</div>
  </header>

  <!-- CONTENT -->
  <main class="stack">
    <div class="grid">
      <!-- LEFT: Adventure Control -->
      <section class="card">
        <h2 class="section-title">‚öì Adventure Control</h2>
        <div id="timer">-- : -- : --</div>
        <div class="status"><span id="statusPill" class="pill">Checking‚Ä¶</span></div>

        <div class="grid2">
          <button id="btnStart" class="btn">üç≠ Launch</button>
          <button id="btnPause" class="btn pause">‚è∏ Pause</button>
          <button id="btnEnd" class="btn end">üü• End</button>
          <button id="btnReset" class="btn reset">üîÅ Reset</button>
        </div>

        <div class="grid1">
          <button id="btnPublish" class="btn publish">üì¢ Publish Results</button>
          <!-- NEW: Final Results button -->
          <button id="btnFinalResults" class="btn final" disabled>üèÅ Final Results</button>
        </div>

        <div class="stats">
          <div class="stat"><small>Total Crews</small><h3 id="statTotal">‚Äî</h3></div>
          <div class="stat"><small>Active</small><h3 id="statActive">‚Äî</h3></div>
          <div class="stat"><small>Returned</small><h3 id="statReturned">0</h3></div>
        </div>
      </section>

      <!-- RIGHT: Crew Management -->
      <section class="card">
        <h2 class="section-title">üßë‚Äç‚úàÔ∏è Crew Management</h2>
        <div id="teams" class="teams"></div>
      </section>
    </div>
  </main>

  <script>
    // Mobile menu + preserve ?event=
    (function(){
      const navToggle = document.getElementById('nav-toggle');
      const navMenu   = document.getElementById('nav-menu');
      const qs = new URLSearchParams(location.search);
      const EVENT_ID = qs.get('event') || qs.get('eventId') || '';

      // Rewrite nav links to keep the event param
      document.querySelectorAll('.nav-menu a').forEach(a=>{
        const url = new URL(a.href, location.origin);
        if (EVENT_ID) url.searchParams.set('event', EVENT_ID);
        a.href = url.toString();
      });

      if(navToggle && navMenu){
        navToggle.addEventListener('click', ()=> {
          navMenu.classList.toggle('active');
          navToggle.textContent = navMenu.classList.contains('active') ? '‚úï' : '‚ò∞';
        });
        document.addEventListener('click', (e)=> {
          const inside = navToggle.contains(e.target) || navMenu.contains(e.target);
          if(!inside && navMenu.classList.contains('active')){ navMenu.classList.remove('active'); navToggle.textContent='‚ò∞'; }
        });
      }
    })();
  </script>

  <!-- Functional JS + leaderboard totals -->
  <script>
    const qs = new URLSearchParams(location.search);
    const EVENT_ID = qs.get('event');
    if (!EVENT_ID) alert('Missing ?event=EVT-... in the URL');

    const ADMIN_KEY = qs.get('key') || localStorage.getItem('adminKey') || '';
    if (qs.get('key')) localStorage.setItem('adminKey', qs.get('key'));

    // Fixed final results key per request
    const FINAL_RESULTS_KEY = 'QXrPBXGrZI';

    const endpoints = {
      state: '/.netlify/functions/get_event_state',
      start: '/.netlify/functions/admin_start_event',
      teams: '/.netlify/functions/admin_list_teams',
      markReturn: '/.netlify/functions/admin_mark_return',
      leaderboard: '/.netlify/functions/get_leaderboard',
    };

    const el = {
      timer: document.getElementById('timer'),
      statusPill: document.getElementById('statusPill'),
      btnStart: document.getElementById('btnStart'),
      btnPause: document.getElementById('btnPause'),
      btnEnd: document.getElementById('btnEnd'),
      btnReset: document.getElementById('btnReset'),
      btnPublish: document.getElementById('btnPublish'),
      btnFinalResults: document.getElementById('btnFinalResults'),
      teams: document.getElementById('teams'),
      statTotal: document.getElementById('statTotal'),
      statActive: document.getElementById('statActive'),
      statReturned: document.getElementById('statReturned'),
    };

    /* tiny star icon used in the points pill */
    const STAR_SVG = `
      <svg class="star" viewBox="0 0 24 24" aria-hidden="true">
        <path d="M12 2.8l2.8 5.7 6.3.9-4.6 4.5 1.1 6.3L12 17.8l-5.6 2.9 1.1-6.3-4.6-4.5 6.3-.9L12 2.8z" fill="#b37e00"/>
      </svg>`;

    const headers = () => {
      const h = {'Content-Type':'application/json'};
      if (ADMIN_KEY) h['Authorization'] = 'Bearer ' + ADMIN_KEY;
      return h;
    };

    const normState = (s='') => {
      const v = (s || '').toString().trim().toLowerCase();
      if (['published'].includes(v)) return 'published';
      if (['running','started','start','active'].includes(v)) return 'running';
      if (['paused','pause'].includes(v)) return 'paused';
      if (['ended','end','stopped','stop','complete','completed','finished'].includes(v)) return 'ended';
      if (['notstarted','idle','ready','pending',''].includes(v)) return 'notstarted';
      return 'unknown';
    };

    const fmt = (ms) => {
      if (ms < 0) ms = 0;
      const t = Math.floor(ms/1000);
      const hh = String(Math.floor(t/3600)).padStart(2,'0');
      const mm = String(Math.floor((t%3600)/60)).padStart(2,'0');
      const ss = String(t%60).padStart(2,'0');
      return `${hh} : ${mm} : ${ss}`;
    };

    let current = {
      state: 'unknown',
      startedAt: null, endsAt: null,
      durationSec: null, remainingMs: 0,
      lastUpdateAt: 0, prevState: 'unknown',
    };
    let initialDurationSec = null;

    // Track team counts to decide Final Results readiness
    let teamTotals = { total: 0, returned: 0 };

    function setStatusPill(state){
      const s = normState(state);
      el.statusPill.className = 'pill ' + (
        s==='running' ? 'running' : s==='paused' ? 'paused' : s==='ended' ? 'ended' : s==='published' ? 'published' : ''
      );
      el.statusPill.textContent =
        s==='running'   ? 'Running'   :
        s==='paused'    ? 'Paused'    :
        s==='ended'     ? 'Ended'     :
        s==='published' ? 'Published' : 'Not Started';

      el.btnStart.disabled   = (s==='running' || s==='ended' || s==='published');
      el.btnStart.textContent = (s==='paused') ? '‚ñ∂ Resume' : 'üç≠ Launch';
      el.btnPause.disabled   = !(s==='running');
      el.btnEnd.disabled     = (s==='ended' || s==='notstarted' || s==='published');
      el.btnReset.disabled   = (s==='running');
      el.btnPublish.disabled = !(s==='ended');
      el.btnPublish.textContent = (s==='published') ? '‚úÖ Published' : 'üì¢ Publish Results';

      updateFinalButton(); // re-evaluate whenever state changes
    }

    function canShowFinal(){
      const s = normState(current.state);
      const ended = (s === 'ended' || s === 'published'); // once published, also fine
      const everyoneReturned = (teamTotals.total > 0 && teamTotals.returned === teamTotals.total);
      return ended || everyoneReturned;
    }
    function updateFinalButton(){
      if (!el.btnFinalResults) return;
      el.btnFinalResults.disabled = !canShowFinal();
    }

    let rafId = null;
    function tick(){
      cancelAnimationFrame(rafId);
      const now = Date.now();
      let displayMs = 0;
      const s = normState(current.state);

      if (s === 'running' && current.startedAt && current.endsAt){
        displayMs = new Date(current.endsAt).getTime() - now;
        current.remainingMs = displayMs;
      } else if (s === 'paused'){
        displayMs = Math.max(0, current.remainingMs || 0);
      } else if (s === 'ended' || s==='published'){
        displayMs = 0;
      } else {
        const dur = current.durationSec ?? initialDurationSec;
        if (dur != null) displayMs = dur * 1000;
      }
      el.timer.textContent = fmt(displayMs);
      rafId = requestAnimationFrame(tick);
    }

    // Hardened: ignore bad/empty responses to avoid "Not Started" flash
    async function fetchState({force=false}={}) {
      const callAt = Date.now();
      let res;
      try {
        res = await fetch(`${endpoints.state}?eventId=${encodeURIComponent(EVENT_ID)}`, {
          headers: headers(),
          cache: 'no-store'
        });
      } catch { return; }
      if (!res.ok) return;

      const data = await res.json().catch(()=>null);
      if (!data || Object.keys(data).length === 0) return;
      if (!force && callAt < current.lastUpdateAt) return;

      const nextState = normState(
        data.state || (data.running ? 'running' : data.paused ? 'paused' : data.ended ? 'ended' : data.published ? 'published' : 'notstarted')
      );

      if (initialDurationSec == null && typeof data.durationSec === 'number') initialDurationSec = data.durationSec;

      let remainingMs = current.remainingMs;
      if (typeof data.remainingMs === 'number')       remainingMs = data.remainingMs;
      else if (typeof data.remainingSec === 'number') remainingMs = Math.max(0, Math.floor(data.remainingSec * 1000));
      else if (nextState === 'running' && data.endsAt) remainingMs = new Date(data.endsAt).getTime() - Date.now();

      current = {
        ...current,
        prevState: current.state,
        state: nextState,
        startedAt: data.startedAt || data.startIso || current.startedAt,
        endsAt: data.endsAt || data.endIso || current.endsAt,
        durationSec: (data.durationSec ?? current.durationSec ?? initialDurationSec),
        remainingMs: Math.max(0, remainingMs),
        lastUpdateAt: callAt,
      };

      setStatusPill(nextState);
      tick();
    }

    async function postActionSmart(action, extra = {}){
      const tryActions = (action === 'end') ? ['stop','end'] :
                         (action === 'reset') ? ['reset'] :
                         (action === 'publish') ? ['publish'] :
                         [action];

      let lastErr = null;
      for (const a of tryActions){
        const body = { eventId: EVENT_ID, action: a, ...extra };
        try{
          const res = await fetch(endpoints.start, { method:'POST', headers: headers(), body: JSON.stringify(body) });
          const data = await res.json().catch(()=>({success:false, message:'Bad JSON'}));
          if (data && data.success) return {ok:true, data};
          lastErr = data?.message || `Failed ${a}`;
        }catch(e){ lastErr = e.message; }
      }
      return {ok:false, error:lastErr || 'Unknown error'};
    }

    async function doAction(action, extra = {}) {
      if (action === 'pause'){
        const ms = (current.endsAt ? new Date(current.endsAt).getTime() - Date.now() : current.remainingMs) || 0;
        current.remainingMs = Math.max(0, ms);
        current.state = 'paused';
        setStatusPill('paused'); tick();
      }
      if (action === 'end'){
        current.remainingMs = 0; current.state = 'ended';
        setStatusPill('ended'); tick();
      }
      if (action === 'reset'){
        const dur = current.durationSec ?? initialDurationSec ?? 0;
        current.startedAt = null; current.endsAt = null;
        current.remainingMs = dur * 1000; current.state = 'notstarted';
        setStatusPill('notstarted'); tick();
      }
      if (action === 'start'){
        const now = Date.now();
        if (typeof extra.remainingSec === 'number' && extra.remainingSec > 0) {
          current.state = 'running';
          current.endsAt = new Date(now + extra.remainingSec * 1000).toISOString();
        } else {
          const dur = current.durationSec ?? initialDurationSec ?? 0;
          current.state = 'running';
          current.endsAt = new Date(now + dur * 1000).toISOString();
        }
        setStatusPill('running'); tick();
      }
      if (action === 'publish'){
        current.state = 'published';
        setStatusPill('published'); tick();
      }

      const r = await postActionSmart(action, extra);
      if (!r.ok){
        alert(`Failed to ${action}. ${r.error || ''}`.trim());
      }
      await fetchState({force:true});
      updateFinalButton();
    }

    /* ===== Leaderboard merge (totals + rank) ===== */
    async function fetchLeaderboardTotals(){
      try{
        const url = `${endpoints.leaderboard}?eventId=${encodeURIComponent(EVENT_ID)}`;
        const res = await fetch(url, { headers: headers() });
        const data = await res.json().catch(()=>({}));
        const rows = data.leaderboard || data.rows || data.teams || [];
        const map = new Map();
        for (const t of rows){
          const code = (t.teamCode || t.code || '').toString().trim().toUpperCase();
          const name = (t.teamName || t.name || t.team || '').toString().trim().toUpperCase();
          const k = Number(t.kindness ?? t.scores?.kindness ?? t.activities?.kindness ?? 0);
          const l = Number(t.limerick ?? t.scores?.limerick ?? t.activities?.limerick ?? 0);
          const s = Number(t.scavenger ?? t.scores?.scavenger ?? t.activities?.scavenger ?? 0);
          const c = Number(t.cluehunt ?? t.scores?.cluehunt ?? t.activities?.cluehunt ?? 0);
          const q = Number(t.quiz ?? t.scores?.quiz ?? t.activities?.quiz ?? 0);
          const total = Number.isFinite(+t.total) ? +t.total : (k+l+s+c+q);
          if (code) map.set(`CODE:${code}`, total);
          if (name) map.set(`NAME:${name}`, total);
        }
        return (team) => {
          const code = (team.teamCode || '').toString().trim().toUpperCase();
          const name = (team.teamName || '').toString().trim().toUpperCase();
          return map.get(`CODE:${code}`) ?? map.get(`NAME:${name}`) ?? 0;
        };
      }catch{
        return () => 0;
      }
    }

    function addRanks(items, scoreKey='total'){
      let lastScore = null, lastRank = 0;
      items.forEach((it, idx)=>{
        const s = it[scoreKey];
        if (s === lastScore) { it.rank = lastRank; }
        else { it.rank = idx + 1; lastRank = it.rank; lastScore = s; }
      });
    }

    async function loadTeams(){
      const res = await fetch(`${endpoints.teams}?eventId=${encodeURIComponent(EVENT_ID)}`, {headers: headers(), cache:'no-store'});
      const data = await res.json().catch(()=>({teams:[]}));
      let teams = Array.isArray(data.teams) ? data.teams : [];

      // merge totals
      const getTotal = await fetchLeaderboardTotals();
      teams = teams.map(t => ({ ...t, total: getTotal(t) || 0 }));

      // sort & rank
      teams.sort((a,b) => (b.total - a.total) || String(a.teamName||'').localeCompare(String(b.teamName||'')));
      addRanks(teams, 'total');

      // stats
      const returnedCount = teams.filter(t => !!(t.returned || t.hasReturned || t.returnedAt)).length;
      el.statTotal.textContent = teams.length || 0;
      el.statActive.textContent = teams.filter(t => !t.locked && t.active !== false).length || 0;
      el.statReturned.textContent = returnedCount;

      // store for Final Results readiness check
      teamTotals.total = teams.length || 0;
      teamTotals.returned = returnedCount;
      updateFinalButton();

      // render
      el.teams.innerHTML = teams.map(t => {
        const name = (t.teamName || t.name || 'Unnamed crew');
        const code = t.teamCode || t.code || '';
        const tagA = `<span class="tag">${t.active===false ? 'Inactive' : 'Active'}</span>`;
        const tagB = `<span class="tag">${t.locked ? 'Locked' : 'Unlocked'}</span>`;
        const tagC = (t.returned || t.hasReturned || t.returnedAt) ? `<span class="tag" style="border-color:#bfe8ff;background:#eaf8ff;color:#0a4c68">Returned</span>` : '';
        const returned = !!(t.returned || t.hasReturned || t.returnedAt);
        const total = Number.isFinite(+t.total)? +t.total : 0;
        const rank = t.rank || '-';
        return `
          <div class="team ${returned?'returned':''}">
            <div class="row1">
              <div>
                <div style="font-weight:900;color:#4a351e;display:flex;align-items:center;gap:10px;flex-wrap:wrap">
                  <span class="team-rank" title="Current rank">#${rank}</span>
                  <span>${name}</span>
                </div>
                <div class="meta">${tagA}${tagB}${tagC}<span class="tag">${code || 'TEAM'}</span></div>
              </div>
              <div class="actions" style="display:flex;flex-direction:column;align-items:flex-end;gap:8px">
                <div class="team-row-points">
                  <div class="team-points" title="Current total points">
                    ${STAR_SVG}<span class="num">${total}</span>
                  </div>
                </div>
                <button class="btn secondary" data-action="${returned?'undoReturn':'markReturn'}" data-team="${code}">
                  ${returned?'‚Ü©Ô∏é Undo Return':'‚úÖ Mark Returned'}
                </button>
              </div>
            </div>
          </div>`;
      }).join('');

      // wire mark/undo
      el.teams.querySelectorAll('button[data-action]').forEach(btn=>{
        btn.addEventListener('click', async ()=>{
          const teamCode = btn.getAttribute('data-team');
          const action = btn.getAttribute('data-action');
          try{
            const payload = {
              eventId: EVENT_ID,
              teamCode,
              returnedAt: new Date().toISOString(),
              undo: action === 'undoReturn'
            };
            const res = await fetch(endpoints.markReturn, {
              method:'POST', headers: headers(), body: JSON.stringify(payload)
            });
            const data = await res.json().catch(()=>({success:false}));
            if (!data.success) {
              alert(data.message || 'Failed to mark/undo return.');
              return;
            }
            await loadTeams();
          }catch(e){
            alert('admin_mark_return not available (or network error).');
          }
        });
      });
    }

    // Wire UI
    el.btnStart.addEventListener('click', async () => {
      const s = normState(current.state);
      if (s === 'paused') {
        const remainingSec = Math.max(0, Math.ceil((current.remainingMs || 0) / 1000));
        await doAction('start', { remainingSec });
      } else {
        await doAction('start');
      }
    });
    el.btnPause.addEventListener('click', () => doAction('pause'));
    el.btnEnd.addEventListener('click',   () => doAction('end'));
    el.btnReset.addEventListener('click', async () => {
      const ok = confirm('Are you sure you want to reset the timer?\n\nThis sets the event to ‚ÄúNot started‚Äù and clears start/end times.');
      if (!ok) return;
      await doAction('reset');
    });
    el.btnPublish.addEventListener('click', async () => {
      const ok = confirm('Publish results now?\n\nThis will:\n‚Ä¢ Show FINAL results on the leaderboard\n‚Ä¢ Unlock the Gallery (Limericks + Kindness)\nThis action is safe (you can still edit scores later).');
      if (!ok) return;
      await doAction('publish');
    });

    // NEW: Final Results click
    el.btnFinalResults.addEventListener('click', () => {
      if (el.btnFinalResults.disabled) return;
      const url = new URL('/final_results', location.origin);
      url.searchParams.set('event', EVENT_ID);
      url.searchParams.set('key', FINAL_RESULTS_KEY);
      location.href = url.toString();
    });

    // Interval with in-flight guard to prevent overlapping polls
    let polling = false;
    (async function init(){
      await fetchState({force:true});
      await loadTeams();
      setInterval(async ()=>{
        if (polling) return;
        polling = true;
        try{
          await fetchState();
          await loadTeams();
        } finally {
          polling = false;
        }
      }, 3000);
    })();
  </script>
</body>
</html>
