<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Terry's Treasure Hunt — Command Centre</title>
  <style>
    /* ————————— Top Nav ————————— */
    .treasure-nav{
      position:fixed;top:0;left:0;right:0;height:70px;z-index:1000;
      background:linear-gradient(135deg,#8B4513 0%,#654321 50%,#8B4513 100%);
      border-bottom:3px solid #DAA520;box-shadow:0 4px 15px rgba(0,0,0,.3);
      font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;padding:0 20px
    }
    .nav-container{max-width:1200px;margin:0 auto;height:100%;display:flex;justify-content:center;align-items:center}
    .nav-logo{display:flex;align-items:center;text-decoration:none;transition:.3s}
    .nav-logo:hover{transform:scale(1.05)}
    .nav-logo img{height:45px;width:auto;filter:drop-shadow(2px 2px 4px rgba(0,0,0,.5));transition:.3s}
    .nav-logo:hover img{filter:drop-shadow(2px 2px 8px rgba(255,215,0,.6))}
    @media(max-width:768px){.treasure-nav{height:90px}.nav-logo img{height:65px}}

    /* ————————— Base ————————— */
    *{margin:0;padding:0;box-sizing:border-box}
    body{
      font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif;
      background:linear-gradient(135deg,#8B4513 0%,#D2691E 30%,#F4A460 100%);
      min-height:100vh;color:#3E2723;padding:20px 20px 40px;padding-top:90px;position:relative
    }
    @media(max-width:768px){body{padding:10px;padding-top:110px}}
    body::before{
      content:'';position:fixed;inset:0;pointer-events:none;z-index:0;
      background:
        radial-gradient(circle at 20% 20%,rgba(255,215,0,.1) 0%,transparent 50%),
        radial-gradient(circle at 80% 80%,rgba(255,140,0,.1) 0%,transparent 50%),
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="20" cy="20" r="1" fill="rgba(255,215,0,0.3)"/><circle cx="80" cy="40" r="0.5" fill="rgba(255,140,0,0.2)"/><circle cx="40" cy="80" r="1.5" fill="rgba(218,165,32,0.2)"/></svg>')
    }

    /* ————————— Header ————————— */
    .header{text-align:center;margin-bottom:30px;position:relative;z-index:1}
    .logo{font-size:2.2em;margin-bottom:8px;filter:drop-shadow(2px 2px 4px rgba(139,69,19,.3));animation:gentle-sway 3s ease-in-out infinite}
    @keyframes gentle-sway{0%,100%{transform:rotate(-2deg)}50%{transform:rotate(2deg)}}
    h1{
      font-size:2.2em;font-weight:800;margin-bottom:6px;color:#2C1810;
      text-shadow:4px 4px 8px rgba(255,255,255,.9),2px 2px 4px rgba(255,255,255,.7),1px 1px 2px rgba(0,0,0,.9),-1px -1px 2px rgba(255,255,255,.6)
    }
    .subtitle{
      color:#1A0E08;font-size:1.02em;font-weight:700;
      text-shadow:3px 3px 6px rgba(255,255,255,.8),1px 1px 2px rgba(255,255,255,.6),1px 1px 3px rgba(0,0,0,.8),-1px -1px 1px rgba(255,255,255,.5)
    }

    /* ————————— Terry note ————————— */
    .terry-greeting{display:flex;gap:15px;margin:18px auto 26px;max-width:900px;padding:18px;border-radius:15px;
      border:3px solid #DAA520;background:linear-gradient(135deg,#FFF8DC 0%,#F5E6D3 100%);box-shadow:0 5px 15px rgba(139,69,19,.2);position:relative;z-index:1}
    .terry-character img{width:92px;height:92px;border-radius:12px;border:3px solid #DAA520;box-shadow:0 4px 12px rgba(139,69,19,.3);object-fit:cover}
    .terry-speech{flex:1;position:relative}
    .terry-speech::before{content:'';position:absolute;left:-12px;top:15px;border-style:solid;border-width:12px 12px 12px 0;border-color:transparent #FFD700 transparent transparent}
    .terry-note{background:linear-gradient(135deg,#FFD700 0%,#FFA500 100%);color:#8B4513;padding:16px;border-radius:12px;border:2px solid #DAA520;font-weight:600}

    /* ————————— Layout ————————— */
    .admin-container{max-width:1400px;margin:0 auto;display:grid;grid-template-columns:1fr 1fr;gap:20px;position:relative;z-index:1}
    @media(max-width:1200px){.admin-container{grid-template-columns:1fr}}
    .panel{
      background:linear-gradient(145deg,#F5E6D3 0%,#E8D7C3 100%);border:3px solid #8B4513;border-radius:20px;padding:22px;
      box-shadow:0 20px 40px rgba(0,0,0,.2), inset 0 1px 0 rgba(255,255,255,.3);position:relative;overflow:hidden
    }
    .panel::before{content:'';position:absolute;left:0;right:0;top:0;height:6px;background:linear-gradient(90deg,#FFD700,#FF8C00,#DAA520,#FFD700)}
    .inner-outline{position:absolute;inset:12px;border:2px solid #DAA520;border-radius:15px;pointer-events:none}

    .section-title{font-size:1.25em;font-weight:800;color:#8B4513;border-bottom:3px solid #DAA520;padding-bottom:8px;margin-bottom:16px}

    /* ——— Adventure controls ——— */
    .timer-display{
      font-size:2.2em;font-weight:800;font-family:'Courier New',monospace;color:#8B4513;
      padding:14px;text-align:center;margin:10px auto;border-radius:12px;border:3px solid #DAA520;
      background:linear-gradient(135deg,#FFD700 0%,#FFA500 100%);box-shadow:0 5px 15px rgba(255,215,0,.3)
    }
    .timer-penalty{background:linear-gradient(135deg,#DC143C 0%,#B22222 100%);color:#fff;border-color:#8B0000;animation:pulse-pen 1s ease-in-out infinite}
    @keyframes pulse-pen{0%,100%{transform:scale(1);box-shadow:0 5px 15px rgba(220,20,60,.4)}50%{transform:scale(1.02);box-shadow:0 8px 25px rgba(220,20,60,.6)}}

    .status{font-weight:800;border:2px solid;border-radius:10px;padding:10px;text-align:center;margin:10px auto 18px}
    .status.stopped{background:linear-gradient(135deg,#FFB6C1 0%,#FFA0B4 100%);border-color:#DC143C;color:#8B0000}
    .status.running{background:linear-gradient(135deg,#98FB98 0%,#90EE90 100%);border-color:#32CD32;color:#006400}
    .status.ended{background:linear-gradient(135deg,#FFD700 0%,#FFA500 100%);border-color:#DAA520;color:#8B4513}
    .status.not-started{background:linear-gradient(135deg,#E6E6FA 0%,#D8BFD8 100%);border-color:#9370DB;color:#4B0082}

    .controls{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:14px}
    @media(max-width:480px){.controls{grid-template-columns:1fr}}
    .btn{
      padding:14px 18px;border:none;border-radius:10px;font-weight:800;letter-spacing:.5px;cursor:pointer;
      border:3px solid #8B4513;text-shadow:1px 1px 2px rgba(0,0,0,.2);transition:.2s
    }
    .btn:hover{transform:translateY(-2px);box-shadow:0 6px 15px rgba(0,0,0,.25)}
    .btn:disabled{opacity:.55;cursor:not-allowed;box-shadow:none;transform:none}
    .btn-start{background:linear-gradient(135deg,#32CD32,#228B22);color:#fff}
    .btn-pause{background:linear-gradient(135deg,#FFD700,#FF8C00);color:#8B4513}
    .btn-stop{background:linear-gradient(135deg,#DC143C,#B22222);color:#fff}
    .btn-reset{background:linear-gradient(135deg,#A0522D,#8B4513);color:#fff}
    .btn-publish{grid-column:1/-1;background:linear-gradient(135deg,#FFD700,#FFA500);color:#8B4513;border-width:4px}

    /* ——— Results block ——— */
    .results-box{background:linear-gradient(135deg,#FFFACD 0%,#F0E68C 100%);border:3px solid #DAA520;border-radius:12px;padding:14px;margin-top:12px}
    .results-status{font-weight:800;text-align:center;border-radius:8px;padding:10px;margin-top:10px}
    .rs-unpub{background:linear-gradient(135deg,#FFE4B5 0%,#DEB887 100%);border:2px solid #FF8C00;color:#8B4513}
    .rs-pub{background:linear-gradient(135deg,#98FB98 0%,#90EE90 100%);border:2px solid #32CD32;color:#006400}

    /* ——— Crew panel ——— */
    .grid{display:grid;gap:12px;max-height:600px;overflow:auto}
    .card{
      background:linear-gradient(135deg,#FFF8DC 0%,#F5E6D3 100%);border:2px solid #DAA520;border-radius:12px;
      padding:14px;box-shadow:0 4px 12px rgba(139,69,19,.1)
    }
    .card.returned{background:linear-gradient(135deg,#98FB98 0%,#90EE90 100%);border:3px solid #32CD32}
    .card.late{background:linear-gradient(135deg,#FFCCCB 0%,#FFA0B4 100%);border:3px solid #DC143C}
    .card.penalized{border-left:6px solid #DC143C}
    .card-head{display:flex;justify-content:space-between;gap:10px;align-items:flex-start}
    .name{font-weight:900;color:#8B4513}
    .badge{padding:3px 6px;border-radius:10px;font-size:.65em;font-weight:800;margin-left:8px}
    .b-active{background:#3498db;color:#fff}.b-returned{background:#27ae60;color:#fff}.b-late{background:#e74c3c;color:#fff}
    .score{font-weight:900;color:#DAA520;display:flex;flex-direction:column;align-items:flex-end}
    .score.pen{color:#DC143C}.orig{font-size:.65em;color:#888;text-decoration:line-through;margin-bottom:2px}
    .controls-row{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin:10px 0}
    .select{padding:8px 10px;border:2px solid #DAA520;border-radius:8px;background:linear-gradient(145deg,#fff 0%,#FFF8DC 100%);font-weight:600;color:#8B4513}
    .lock{display:flex;align-items:center;gap:6px;font-size:.85em;font-weight:600}
    .pen-box{display:none;background:linear-gradient(135deg,#FFE4B5 0%,#DEB887 100%);border:2px solid #FF8C00;border-radius:8px;padding:10px}
    .pen-box.show{display:block}
    .pen-in{width:70px;text-align:center;padding:6px 8px;border:2px solid #DAA520;border-radius:6px;font-weight:800;color:#8B4513}
    .pen-btn{background:linear-gradient(135deg,#FF8C00,#FF7700);color:#fff;border:none;border-radius:6px;padding:6px 10px;font-weight:800;cursor:pointer}
    .pill{font-size:.78em;color:#8B4513;margin-top:6px}

    .loading{text-align:center;color:#8B4513;font-weight:700;padding:16px}
    .msg{padding:12px;border-radius:10px;margin:12px 0;font-weight:700;border:2px solid}
    .msg.ok{background:linear-gradient(135deg,#98FB98 0%,#90EE90 100%);border-color:#32CD32;color:#064d06}
    .msg.err{background:linear-gradient(135deg,#FFB6C1 0%,#FFA0B4 100%);border-color:#DC143C;color:#8B0000}

    /* ——— Stats ——— */
    .stats{max-width:1400px;margin:18px auto 0;display:grid;grid-template-columns:repeat(4,1fr);gap:14px}
    .s{background:linear-gradient(145deg,#F5E6D3 0%,#E8D7C3 100%);border:3px solid #8B4513;border-radius:12px;padding:16px;text-align:center}
    .s:before{content:'';display:block;height:4px;background:linear-gradient(90deg,#FFD700,#FF8C00,#DAA520,#FFD700);margin:-16px -16px 12px;border-top-left-radius:12px;border-top-right-radius:12px}
    .s-num{font-size:1.6em;font-weight:900;color:#8B4513}
    .s-lbl{font-weight:700;color:#A0522D;margin-top:6px}
    @media(max-width:768px){.admin-container{gap:14px}.stats{grid-template-columns:repeat(2,1fr)}}
  </style>
</head>
<body>
  <!-- Nav -->
  <nav class="treasure-nav">
    <div class="nav-container">
      <a class="nav-logo" href="/">
        <img src="/Team Quest Logo-01.png" alt="TeamQuest Logo">
      </a>
    </div>
  </nav>

  <!-- Header -->
  <div class="header">
    <div class="logo">🏴‍☠️</div>
    <h1>Command Centre</h1>
    <p class="subtitle">Start • Pause • End • Publish • Manage Crews</p>
  </div>

  <!-- Terry note -->
  <div class="terry-greeting">
    <div class="terry-character"><img src="/terry-clock.png" alt="Captain Terry"></div>
    <div class="terry-speech">
      <div class="terry-note">
        Keep it simple: launch the adventure, watch the clock, mark returns — late returns auto-deduct based on the configured rate.
      </div>
    </div>
  </div>

  <div class="admin-container">
    <!-- Adventure control -->
    <section class="panel">
      <div class="inner-outline"></div>
      <h2 class="section-title">⚓ Adventure Control</h2>

      <div id="timerDisplay" class="timer-display">--:--:--</div>
      <div id="timerStatus" class="status not-started">Not Started</div>

      <div class="controls">
        <button id="startBtn"  class="btn btn-start" onclick="startAdventure()">🚀 Launch</button>
        <button id="pauseBtn"  class="btn btn-pause" onclick="pauseAdventure()" disabled>⏸️ Pause</button>
        <button id="stopBtn"   class="btn btn-stop"  onclick="stopAdventure()"  disabled>⏹️ End</button>
        <button id="resetBtn"  class="btn btn-reset" onclick="resetTimer()">🔄 Reset</button>
        <button id="publishBtn"class="btn btn-publish" onclick="publishResults()" disabled>🏆 Publish Final Results</button>
      </div>

      <div class="results-box">
        <div id="resultsStatus" class="results-status rs-unpub">🔒 Results not published</div>
      </div>
    </section>

    <!-- Crew management -->
    <section class="panel">
      <div class="inner-outline"></div>
      <h2 class="section-title">👥 Crew Management</h2>

      <div id="loading" class="loading">🔎 Loading crews…</div>

      <div id="crewsContent" style="display:none">
        <div id="crewsGrid" class="grid"></div>
      </div>

      <div id="messages"></div>
    </section>
  </div>

  <!-- Stats -->
  <div class="stats">
    <div class="s"><div id="totalCrews"   class="s-num">-</div><div class="s-lbl">Total Crews</div></div>
    <div class="s"><div id="activeCrews"  class="s-num">-</div><div class="s-lbl">Active</div></div>
    <div class="s"><div id="returnedCrews"class="s-num">-</div><div class="s-lbl">Returned</div></div>
    <div class="s"><div id="penalizedCrews"class="s-num">-</div><div class="s-lbl">Penalised</div></div>
  </div>

  <script>
    /* =======================
       Endpoints (new names)
       ======================= */
    const FN = (n) => `${location.origin}/.netlify/functions/${n}`;
    const GET_STATE_FN       = 'get_event_state';
    const GET_LEADERBOARD_FN = 'get_leaderboard';
    const START_EVENT_FN     = 'admin_start_event';
    const PUBLISH_RESULTS_FN = 'admin_publish_final';
    const CHECKIN_TEAM_FN    = 'admin_checkin_team';
    const TOGGLE_LOCK_FN     = 'admin_toggle_lock_team';

    /* =======================
       State
       ======================= */
    let adventureState = {
      backendStatus:null,
      isRunning:false,
      isPaused:false,
      hasEnded:false,
      timeRemaining:90*60,
      startTime:null,
      crews:[],
      resultsPublished:false,
      competitionData:null,
      penaltyMode:false,
      penaltyMinutes:0,
      allTeamsReturned:false
    };

    let timerInterval=null, dataInterval=null;

    document.addEventListener('DOMContentLoaded', () => {
      loadCurrentState();
      dataInterval = setInterval(loadCurrentState, 30000);
    });

    window.addEventListener('beforeunload', () => {
      if (timerInterval) clearInterval(timerInterval);
      if (dataInterval) clearInterval(dataInterval);
    });

    /* =======================
       Load / Sync
       ======================= */
    async function loadCurrentState(){
      try{
        // primary state
        let res = await fetch(FN(GET_STATE_FN));
        let data = await res.json();
        if(!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);

        // fallback to leaderboard if needed
        if(!data || (!data.success && !Array.isArray(data.teams) && !Array.isArray(data.leaderboard))){
          const r2 = await fetch(FN(GET_LEADERBOARD_FN));
          const d2 = await r2.json();
          if(r2.ok) data = d2;
        }

        adventureState.backendStatus    = (data.competitionStatus || data.status || '').toLowerCase();
        adventureState.resultsPublished = data.resultsPublished === true || data.resultsPublished === 'yes';
        adventureState.crews            = data.teams || data.leaderboard || [];
        adventureState.competitionData  = data;

        // compute timer if we have times
        if(data.startTime && data.durationMinutes){
          const end = new Date(data.startTime).getTime() + data.durationMinutes*60*1000;
          const now = Date.now();
          adventureState.timeRemaining = Math.max(0, Math.floor((end-now)/1000));
          adventureState.penaltyMode   = now > end;
          adventureState.penaltyMinutes= adventureState.penaltyMode ? Math.ceil((now-end)/60000) : 0;
        }

        syncWithBackendState();
        updateTimerDisplay();
        updateButtons();
        updateResultsBox();
        renderCrews(adventureState.crews);
        updateStats(adventureState.crews);

        document.getElementById('loading').style.display='none';
        document.getElementById('crewsContent').style.display='block';
      }catch(e){
        show('Failed to load current status: '+e.message,'err');
      }
    }

    function syncWithBackendState(){
      const st = adventureState.backendStatus;
      if(st==='start' || st==='running'){
        adventureState.isRunning = true;
        adventureState.isPaused  = false;
        adventureState.hasEnded  = false;
        if(!timerInterval) startTicker();
      }else if(st==='stop' || st==='stopped'){
        adventureState.isRunning=false;
        adventureState.isPaused=false;
        adventureState.hasEnded=true;
        if(timerInterval){clearInterval(timerInterval);timerInterval=null;}
      }else{
        adventureState.isRunning=false;
        adventureState.isPaused=false;
        adventureState.hasEnded=false;
        adventureState.timeRemaining = adventureState.timeRemaining || 90*60;
        if(timerInterval){clearInterval(timerInterval);timerInterval=null;}
      }
      // all returned?
      const active = adventureState.crews.filter(c => (c.status||'active')==='active').length;
      adventureState.allTeamsReturned = adventureState.crews.length>0 && active===0;
    }

    /* =======================
       Timer
       ======================= */
    function startTicker(){
      if(timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(()=>{
        if(adventureState.isRunning && !adventureState.isPaused){
          if(adventureState.timeRemaining>0){
            adventureState.timeRemaining--;
            if(adventureState.timeRemaining<=0){
              adventureState.penaltyMode = true;
              adventureState.penaltyMinutes = 1;
              show('⚠️ Time expired — late penalties active','err');
            }
          }else if(adventureState.penaltyMode && !adventureState.allTeamsReturned){
            // derive from real time if startTime present
            const d = adventureState.competitionData;
            if(d?.startTime && d?.durationMinutes){
              const end = new Date(d.startTime).getTime()+d.durationMinutes*60*1000;
              adventureState.penaltyMinutes = Math.max(1, Math.ceil((Date.now()-end)/60000));
            }else{
              adventureState.penaltyMinutes++;
            }
          }
          updateTimerDisplay(); updateResultsBox();
        }
      },1000);
    }

    function fmt(sec){
      const h=Math.floor(sec/3600), m=Math.floor((sec%3600)/60), s=sec%60;
      return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function updateTimerDisplay(){
      const el = document.getElementById('timerDisplay');
      const st = document.getElementById('timerStatus');

      if(adventureState.penaltyMode && adventureState.isRunning){
        const p = adventureState.penaltyMinutes*60;
        el.textContent = `+${fmt(p)}`;
        el.className = 'timer-display timer-penalty';
        st.textContent = adventureState.allTeamsReturned ? 'All Crews Returned' : 'Penalty Phase';
        st.className = 'status stopped';
      }else{
        el.textContent = fmt(Math.max(0, adventureState.timeRemaining));
        el.className = 'timer-display';
        if(adventureState.resultsPublished){ st.textContent='Final Results Published'; st.className='status ended'; }
        else if(adventureState.hasEnded){     st.textContent='Adventure Complete';     st.className='status ended'; }
        else if(adventureState.isRunning){    st.textContent='Adventure in Progress';  st.className='status running'; }
        else{                                  st.textContent='Not Started';            st.className='status not-started'; }
      }
    }

    /* =======================
       Buttons / Results UI
       ======================= */
    function updateButtons(){
      const start=document.getElementById('startBtn');
      const pause=document.getElementById('pauseBtn');
      const stop =document.getElementById('stopBtn');
      const reset=document.getElementById('resetBtn');
      const pub  =document.getElementById('publishBtn');

      if(adventureState.resultsPublished){
        start.disabled=pause.disabled=stop.disabled=true; reset.disabled=false; pub.disabled=true;
        start.textContent='🏆 Results Published';
      }else if(adventureState.hasEnded || adventureState.allTeamsReturned){
        start.disabled=true; pause.disabled=true; stop.disabled=true; reset.disabled=false; pub.disabled=false;
        start.textContent='🔒 Adventure Ended';
      }else if(adventureState.isRunning){
        start.disabled=true; pause.disabled=false; stop.disabled=false; reset.disabled=true; pub.disabled=true;
        start.textContent='✅ Running';
      }else{
        start.disabled=false; pause.disabled=true; stop.disabled=true; reset.disabled=false; pub.disabled=true;
        start.textContent='🚀 Launch';
      }
    }

    function updateResultsBox(){
      const box = document.getElementById('resultsStatus');
      if(adventureState.resultsPublished){
        box.textContent='🏆 Results Published — Gallery Unlocked';
        box.className='results-status rs-pub';
      }else{
        box.textContent='🔒 Results not published';
        box.className='results-status rs-unpub';
      }
    }

    /* =======================
       Crew rendering
       ======================= */
    function renderCrews(list){
      const grid = document.getElementById('crewsGrid');
      grid.innerHTML='';
      (list||[]).forEach(team=>{
        const code = team.teamCode||team.code||'';
        const name = team.teamName||team.name||code;
        const status = team.status||'active';
        const total = team.totalScore||team.total||0;
        const penalty = team.penalty||0;
        const penMin  = team.penaltyMinutes||0;
        const locked = !!team.locked;

        const adjusted = Math.max(0, total - penalty);
        const card = document.createElement('div');
        let cls = 'card';
        if(status==='returned') cls+=' returned';
        if(status==='late')     cls+=' late';
        if(penalty>0)           cls+=' penalized';
        card.className = cls;

        const badge =
          `<span class="badge ${status==='active'?'b-active':(penalty>0?'b-late':'b-returned')}">
             ${status==='active'?'Active':'Returned'}
           </span>`;

        const score =
          penalty>0
            ? `<div class="score pen"><div class="orig">${total}</div>${adjusted} 🪙</div>`
            : `<div class="score">${total} 🪙</div>`;

        const penInfo = penalty>0
          ? `<div class="pill">⚠️ Late penalty: -${penalty} (${penMin} min)</div>`
          : '';

        const disableControls = !adventureState.isRunning ? 'disabled' : '';

        card.innerHTML = `
          <div class="card-head">
            <div class="name">${name} ${badge}</div>
            ${score}
          </div>

          ${penInfo}

          <div class="controls-row">
            <select class="select ${penalty>0?'b-late':''}"
                    onchange="handleStatusChange('${code}', this.value, ${total}, ${penalty})"
                    ${disableControls}>
              <option value="active"   ${status==='active'?'selected':''}>🏴‍☠️ Active</option>
              <option value="returned" ${status!=='active'?'selected':''}>⚓ Returned</option>
            </select>

            <label class="lock">
              <input type="checkbox" ${locked?'checked':''} ${disableControls}
                     onchange="toggleCrewLock('${code}', this.checked)"/>
              🔒 Lock Doubloons
            </label>
          </div>

          <div class="pen-box ${penalty>0 && adventureState.isRunning?'show':''}" id="penalty-override-${code}">
            <strong>Manual Penalty</strong>
            <div style="margin-top:6px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
              <input id="penalty-input-${code}" class="pen-in" type="number" min="0" step="1" value="${penalty}">
              <span>doubloons</span>
              <button class="pen-btn" onclick="applyManualPenalty('${code}')">Apply</button>
            </div>
          </div>

          <div class="pill">${code} | Reg: ${team.registration||0} • Map: ${team.clueHunt||0} • Quiz: ${team.quiz||0}</div>
        `;
        grid.appendChild(card);
      });
    }

    /* =======================
       Actions (endpoints)
       ======================= */
    async function startAdventure(){
      try{
        const r = await fetch(FN(START_EVENT_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'start'})});
        const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
        adventureState.isRunning=true; adventureState.isPaused=false; startTicker();
        updateButtons(); updateTimerDisplay(); updateResultsBox(); show('🚀 Adventure launched!','ok');
        setTimeout(loadCurrentState,1000);
      }catch(e){show('Failed to launch: '+e.message,'err')}
    }

    async function pauseAdventure(){
      try{
        const r = await fetch(FN(START_EVENT_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'stop'})});
        const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
        adventureState.isPaused=true; adventureState.isRunning=false;
        updateButtons(); updateTimerDisplay(); updateResultsBox(); show('⏸️ Paused','ok');
      }catch(e){show('Failed to pause: '+e.message,'err')}
    }

    async function stopAdventure(){
      try{
        const r = await fetch(FN(START_EVENT_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'stop'})});
        const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
        adventureState.isRunning=false; adventureState.isPaused=false; adventureState.hasEnded=true;
        if(timerInterval){clearInterval(timerInterval);timerInterval=null;}
        updateButtons(); updateTimerDisplay(); updateResultsBox(); show('⚓ Adventure ended','ok');
      }catch(e){show('Failed to end: '+e.message,'err')}
    }

    async function resetTimer(){
      if(!confirm('Reset for a new adventure?')) return;
      try{
        const r = await fetch(FN(START_EVENT_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'reset'})});
        const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);

        adventureState = {backendStatus:null,isRunning:false,isPaused:false,hasEnded:false,timeRemaining:90*60,startTime:null,
                          crews:[],resultsPublished:false,competitionData:null,penaltyMode:false,penaltyMinutes:0,allTeamsReturned:false};
        if(timerInterval){clearInterval(timerInterval);timerInterval=null;}
        updateButtons(); updateTimerDisplay(); updateResultsBox(); renderCrews([]);
        show('🔄 Reset complete','ok');
      }catch(e){show('Failed to reset: '+e.message,'err')}
    }

    async function publishResults(){
      if(!confirm('Publish final results and unlock the gallery?')) return;
      try{
        const r = await fetch(FN(PUBLISH_RESULTS_FN), {method:'POST'});
        const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
        adventureState.resultsPublished=true; updateButtons(); updateTimerDisplay(); updateResultsBox();
        show('🏆 Results published','ok');
      }catch(e){show('Failed to publish: '+e.message,'err')}
    }

    // Status changes / penalties / locking
    let pendingChange=null;
    function handleStatusChange(code,newStatus,currentScore,currentPenalty){
      if(newStatus==='returned'){
        // auto late if in penalty window
        const penalty = (adventureState.penaltyMode && adventureState.penaltyMinutes>0)
          ? adventureState.penaltyMinutes*3 : 0;
        updateCrewStatus(code, penalty>0?'late':'returned', penalty);
      }else{
        updateCrewStatus(code,'active',0);
      }
    }

    async function updateCrewStatus(teamCode,status,penalty){
      try{
        const payload = {
          teamCode,
          status,
          penalty: penalty||0,
          penaltyMinutes: penalty ? Math.ceil(penalty/3) : (adventureState.penaltyMinutes||0),
          returnTime: new Date().toISOString()
        };
        const r = await fetch(FN(CHECKIN_TEAM_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
        const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
        await loadCurrentState();
        show(status==='active'?'Crew set active': (penalty>0? `Returned late (-${penalty})` : 'Returned'),'ok');
      }catch(e){show('Failed to update crew: '+e.message,'err')}
    }

    async function applyManualPenalty(teamCode){
      const v = parseInt(document.getElementById(`penalty-input-${teamCode}`).value)||0;
      await updateCrewStatus(teamCode, v>0?'late':'returned', v);
    }

    async function toggleCrewLock(teamCode,locked){
      try{
        const r = await fetch(FN(TOGGLE_LOCK_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({teamCode,locked:!!locked})});
        const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
        show(`Crew ${teamCode} ${locked?'locked':'unlocked'}`,'ok');
      }catch(e){show('Failed to toggle lock: '+e.message,'err')}
    }

    /* =======================
       Stats / Messages
       ======================= */
    function updateStats(crews){
      const total = crews.length;
      const active = crews.filter(c=>(c.status||'active')==='active').length;
      const returned = crews.filter(c=>['returned','late'].includes(c.status)).length;
      const penalized = crews.filter(c=>(c.penalty||0)>0).length;
      document.getElementById('totalCrews').textContent=total;
      document.getElementById('activeCrews').textContent=active;
      document.getElementById('returnedCrews').textContent=returned;
      document.getElementById('penalizedCrews').textContent=penalized;
    }

    function show(text,type){
      const box=document.getElementById('messages');
      const el=document.createElement('div');
      el.className='msg '+(type==='err'?'err':'ok');
      el.textContent=text;
      box.appendChild(el);
      setTimeout(()=>{el.remove()},4500);
    }
  </script>
  <script>
  /* =======================
     Endpoints (new names)
     ======================= */
  const FN = (n, q) => {
    const url = new URL(`${location.origin}/.netlify/functions/${n}`);
    if (q) Object.entries(q).forEach(([k, v]) => (v !== undefined && v !== null) && url.searchParams.set(k, v));
    return url.toString();
  };
  const urlParams = new URLSearchParams(location.search);
  const EVENT_ID = urlParams.get('event') || undefined;

  const GET_STATE_FN       = 'get_event_state';
  const LIST_TEAMS_FN      = 'admin_list_teams';
  const GET_LEADERBOARD_FN = 'get_leaderboard';
  const START_EVENT_FN     = 'admin_start_event';
  const PUBLISH_RESULTS_FN = 'admin_publish_final';
  const CHECKIN_TEAM_FN    = 'admin_checkin_team';
  const TOGGLE_LOCK_FN     = 'admin_toggle_lock_team';

  /* =======================
     State
     ======================= */
  let adventureState = {
    backendStatus:null,
    isRunning:false,
    isPaused:false,
    hasEnded:false,
    timeRemaining:90*60,
    startTime:null,
    crews:[],
    resultsPublished:false,
    competitionData:null,
    penaltyMode:false,
    penaltyMinutes:0,
    allTeamsReturned:false
  };

  let timerInterval=null, dataInterval=null;

  document.addEventListener('DOMContentLoaded', () => {
    loadCurrentState();
    dataInterval = setInterval(loadCurrentState, 30000);
  });

  window.addEventListener('beforeunload', () => {
    if (timerInterval) clearInterval(timerInterval);
    if (dataInterval) clearInterval(dataInterval);
  });

  /* =======================
     Load / Sync
     ======================= */
  async function loadCurrentState(){
    try{
      // 1) Timer / status / results flags
      const stRes = await fetch(FN(GET_STATE_FN, EVENT_ID ? {eventId: EVENT_ID} : undefined));
      const st = await stRes.json();
      if(!stRes.ok) throw new Error(st?.error || `HTTP ${stRes.status}`);

      adventureState.backendStatus    = (st.competitionStatus || st.status || '').toLowerCase();
      adventureState.resultsPublished = st.resultsPublished === true || st.resultsPublished === 'yes';
      adventureState.competitionData  = st;

      // 2) Crews — primary: admin_list_teams
      let teams = [];
      try{
        const listRes = await fetch(FN(LIST_TEAMS_FN, EVENT_ID ? {eventId: EVENT_ID} : undefined));
        const list = await listRes.json();
        if (listRes.ok && (list.success || Array.isArray(list.teams))) {
          teams = list.teams || [];
        }
      }catch(e){
        // soft-fail; we’ll try leaderboard next
        console.warn('admin_list_teams failed:', e);
      }

      // 3) Fallback to leaderboard if needed
      if (teams.length === 0) {
        try{
          const lbRes = await fetch(FN(GET_LEADERBOARD_FN, EVENT_ID ? {eventId: EVENT_ID} : undefined));
          const lb = await lbRes.json();
          if (lbRes.ok && (lb.success || Array.isArray(lb.teams) || Array.isArray(lb.leaderboard))) {
            teams = lb.teams || lb.leaderboard || [];
            // adopt published flag from leaderboard if present
            if (typeof lb.resultsPublished !== 'undefined') {
              adventureState.resultsPublished = lb.resultsPublished === true || lb.resultsPublished === 'yes';
            }
          }
        }catch(e){
          console.warn('get_leaderboard fallback failed:', e);
        }
      }

      adventureState.crews = Array.isArray(teams) ? teams : [];

      // 4) Compute timer / penalty from state
      if(st.startTime && st.durationMinutes){
        const end = new Date(st.startTime).getTime() + st.durationMinutes*60*1000;
        const now = Date.now();
        adventureState.timeRemaining = Math.max(0, Math.floor((end-now)/1000));
        adventureState.penaltyMode   = now > end;
        adventureState.penaltyMinutes= adventureState.penaltyMode ? Math.ceil((now-end)/60000) : 0;
      }

      syncWithBackendState();
      updateTimerDisplay();
      updateButtons();
      updateResultsBox();
      renderCrews(adventureState.crews);
      updateStats(adventureState.crews);

      document.getElementById('loading').style.display='none';
      document.getElementById('crewsContent').style.display='block';
    }catch(e){
      show('Failed to load current status: '+e.message,'err');
      console.error(e);
    }
  }

  function syncWithBackendState(){
    const st = adventureState.backendStatus;
    if(st==='start' || st==='running'){
      adventureState.isRunning = true;
      adventureState.isPaused  = false;
      adventureState.hasEnded  = false;
      if(!timerInterval) startTicker();
    }else if(st==='stop' || st==='stopped'){
      adventureState.isRunning=false;
      adventureState.isPaused=false;
      adventureState.hasEnded=true;
      if(timerInterval){clearInterval(timerInterval);timerInterval=null;}
    }else{
      adventureState.isRunning=false;
      adventureState.isPaused=false;
      adventureState.hasEnded=false;
      if(timerInterval){clearInterval(timerInterval);timerInterval=null;}
    }
    const active = adventureState.crews.filter(c => (c.status||'active')==='active').length;
    adventureState.allTeamsReturned = adventureState.crews.length>0 && active===0;
  }

  /* =======================
     Timer helpers (unchanged)
     ======================= */
  function startTicker(){
    if(timerInterval) clearInterval(timerInterval);
    timerInterval = setInterval(()=>{
      if(adventureState.isRunning && !adventureState.isPaused){
        if(adventureState.timeRemaining>0){
          adventureState.timeRemaining--;
          if(adventureState.timeRemaining<=0){
            adventureState.penaltyMode = true;
            adventureState.penaltyMinutes = 1;
            show('⚠️ Time expired — late penalties active','err');
          }
        }else if(adventureState.penaltyMode && !adventureState.allTeamsReturned){
          const d = adventureState.competitionData;
          if(d?.startTime && d?.durationMinutes){
            const end = new Date(d.startTime).getTime()+d.durationMinutes*60*1000;
            adventureState.penaltyMinutes = Math.max(1, Math.ceil((Date.now()-end)/60000));
          }else{
            adventureState.penaltyMinutes++;
          }
        }
        updateTimerDisplay(); updateResultsBox();
      }
    },1000);
  }
  function fmt(sec){const h=Math.floor(sec/3600),m=Math.floor((sec%3600)/60),s=sec%60;return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;}
  function updateTimerDisplay(){
    const el=document.getElementById('timerDisplay');
    const st=document.getElementById('timerStatus');
    if(adventureState.penaltyMode && adventureState.isRunning){
      el.textContent = `+${fmt(adventureState.penaltyMinutes*60)}`;
      el.className='timer-display timer-penalty';
      st.textContent = adventureState.allTeamsReturned ? 'All Crews Returned' : 'Penalty Phase';
      st.className='status stopped';
    }else{
      el.textContent = fmt(Math.max(0, adventureState.timeRemaining));
      el.className='timer-display';
      if(adventureState.resultsPublished){st.textContent='Final Results Published';st.className='status ended';}
      else if(adventureState.hasEnded){st.textContent='Adventure Complete';st.className='status ended';}
      else if(adventureState.isRunning){st.textContent='Adventure in Progress';st.className='status running';}
      else{st.textContent='Not Started';st.className='status not-started';}
    }
  }

  /* =======================
     Buttons / Results UI (unchanged)
     ======================= */
  function updateButtons(){
    const start=document.getElementById('startBtn');
    const pause=document.getElementById('pauseBtn');
    const stop =document.getElementById('stopBtn');
    const reset=document.getElementById('resetBtn');
    const pub  =document.getElementById('publishBtn');

    if(adventureState.resultsPublished){
      start.disabled=pause.disabled=stop.disabled=true; reset.disabled=false; pub.disabled=true; start.textContent='🏆 Results Published';
    }else if(adventureState.hasEnded || adventureState.allTeamsReturned){
      start.disabled=true; pause.disabled=true; stop.disabled=true; reset.disabled=false; pub.disabled=false; start.textContent='🔒 Adventure Ended';
    }else if(adventureState.isRunning){
      start.disabled=true; pause.disabled=false; stop.disabled=false; reset.disabled=true; pub.disabled=true; start.textContent='✅ Running';
    }else{
      start.disabled=false; pause.disabled=true; stop.disabled=true; reset.disabled=false; pub.disabled=true; start.textContent='🚀 Launch';
    }
  }
  function updateResultsBox(){
    const box = document.getElementById('resultsStatus');
    if(adventureState.resultsPublished){ box.textContent='🏆 Results Published — Gallery Unlocked'; box.className='results-status rs-pub'; }
    else { box.textContent='🔒 Results not published'; box.className='results-status rs-unpub'; }
  }

  /* =======================
     Crew rendering (unchanged)
     ======================= */
  function renderCrews(list){
    const grid = document.getElementById('crewsGrid');
    grid.innerHTML='';
    (list||[]).forEach(team=>{
      const code = team.teamCode||team.code||'';
      const name = team.teamName||team.name||code;
      const status = team.status||'active';
      const total = team.totalScore||team.total||0;
      const penalty = team.penalty||0;
      const penMin  = team.penaltyMinutes||0;
      const locked = !!team.locked;
      const adjusted = Math.max(0, total - penalty);

      const card = document.createElement('div');
      let cls='card'; if(status==='returned')cls+=' returned'; if(status==='late')cls+=' late'; if(penalty>0)cls+=' penalized';
      card.className=cls;

      const badge = `<span class="badge ${status==='active'?'b-active':(penalty>0?'b-late':'b-returned')}">${status==='active'?'Active':'Returned'}</span>`;
      const score = penalty>0 ? `<div class="score pen"><div class="orig">${total}</div>${adjusted} 🪙</div>` : `<div class="score">${total} 🪙</div>`;
      const penInfo = penalty>0 ? `<div class="pill">⚠️ Late penalty: -${penalty} (${penMin} min)</div>` : '';
      const disableControls = !adventureState.isRunning ? 'disabled' : '';

      card.innerHTML = `
        <div class="card-head">
          <div class="name">${name} ${badge}</div>
          ${score}
        </div>
        ${penInfo}
        <div class="controls-row">
          <select class="select ${penalty>0?'b-late':''}"
                  onchange="handleStatusChange('${code}', this.value, ${total}, ${penalty})"
                  ${disableControls}>
            <option value="active"   ${status==='active'?'selected':''}>🏴‍☠️ Active</option>
            <option value="returned" ${status!=='active'?'selected':''}>⚓ Returned</option>
          </select>
          <label class="lock">
            <input type="checkbox" ${locked?'checked':''} ${disableControls}
                   onchange="toggleCrewLock('${code}', this.checked)"/>
            🔒 Lock Doubloons
          </label>
        </div>
        <div class="pen-box ${penalty>0 && adventureState.isRunning?'show':''}" id="penalty-override-${code}">
          <strong>Manual Penalty</strong>
          <div style="margin-top:6px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
            <input id="penalty-input-${code}" class="pen-in" type="number" min="0" step="1" value="${penalty}">
            <span>doubloons</span>
            <button class="pen-btn" onclick="applyManualPenalty('${code}')">Apply</button>
          </div>
        </div>
        <div class="pill">${code} | Reg: ${team.registration||0} • Map: ${team.clueHunt||0} • Quiz: ${team.quiz||0}</div>
      `;
      grid.appendChild(card);
    });
  }

  /* =======================
     Actions (endpoints) — unchanged except all requests carry eventId when present
     ======================= */
  async function startAdventure(){
    try{
      const r = await fetch(FN(START_EVENT_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'start', eventId: EVENT_ID})});
      const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
      adventureState.isRunning=true; adventureState.isPaused=false; startTicker();
      updateButtons(); updateTimerDisplay(); updateResultsBox(); show('🚀 Adventure launched!','ok');
      setTimeout(loadCurrentState,1000);
    }catch(e){show('Failed to launch: '+e.message,'err')}
  }
  async function pauseAdventure(){
    try{
      const r = await fetch(FN(START_EVENT_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'stop', eventId: EVENT_ID})});
      const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
      adventureState.isPaused=true; adventureState.isRunning=false;
      updateButtons(); updateTimerDisplay(); updateResultsBox(); show('⏸️ Paused','ok');
    }catch(e){show('Failed to pause: '+e.message,'err')}
  }
  async function stopAdventure(){
    try{
      const r = await fetch(FN(START_EVENT_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'stop', eventId: EVENT_ID})});
      const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
      adventureState.isRunning=false; adventureState.isPaused=false; adventureState.hasEnded=true;
      if(timerInterval){clearInterval(timerInterval);timerInterval=null;}
      updateButtons(); updateTimerDisplay(); updateResultsBox(); show('⚓ Adventure ended','ok');
    }catch(e){show('Failed to end: '+e.message,'err')}
  }
  async function resetTimer(){
    if(!confirm('Reset for a new adventure?')) return;
    try{
      const r = await fetch(FN(START_EVENT_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({action:'reset', eventId: EVENT_ID})});
      const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
      adventureState = {backendStatus:null,isRunning:false,isPaused:false,hasEnded:false,timeRemaining:90*60,startTime:null,crews:[],resultsPublished:false,competitionData:null,penaltyMode:false,penaltyMinutes:0,allTeamsReturned:false};
      if(timerInterval){clearInterval(timerInterval);timerInterval=null;}
      updateButtons(); updateTimerDisplay(); updateResultsBox(); renderCrews([]);
      show('🔄 Reset complete','ok');
    }catch(e){show('Failed to reset: '+e.message,'err')}
  }
  async function publishResults(){
    if(!confirm('Publish final results and unlock the gallery?')) return;
    try{
      const r = await fetch(FN(PUBLISH_RESULTS_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({eventId: EVENT_ID})});
      const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
      adventureState.resultsPublished=true; updateButtons(); updateTimerDisplay(); updateResultsBox();
      show('🏆 Results published','ok');
    }catch(e){show('Failed to publish: '+e.message,'err')}
  }

  function handleStatusChange(code,newStatus,currentScore,currentPenalty){
    if(newStatus==='returned'){
      const penalty = (adventureState.penaltyMode && adventureState.penaltyMinutes>0) ? adventureState.penaltyMinutes*3 : 0;
      updateCrewStatus(code, penalty>0?'late':'returned', penalty);
    }else{
      updateCrewStatus(code,'active',0);
    }
  }
  async function updateCrewStatus(teamCode,status,penalty){
    try{
      const payload = {
        eventId: EVENT_ID,
        teamCode,
        status,
        penalty: penalty||0,
        penaltyMinutes: penalty ? Math.ceil(penalty/3) : (adventureState.penaltyMinutes||0),
        returnTime: new Date().toISOString()
      };
      const r = await fetch(FN(CHECKIN_TEAM_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
      const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
      await loadCurrentState();
      show(status==='active'?'Crew set active': (penalty>0? `Returned late (-${penalty})` : 'Returned'),'ok');
    }catch(e){show('Failed to update crew: '+e.message,'err')}
  }
  async function applyManualPenalty(teamCode){
    const v = parseInt(document.getElementById(`penalty-input-${teamCode}`).value)||0;
    await updateCrewStatus(teamCode, v>0?'late':'returned', v);
  }
  async function toggleCrewLock(teamCode,locked){
    try{
      const r = await fetch(FN(TOGGLE_LOCK_FN), {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({eventId: EVENT_ID, teamCode, locked:!!locked})});
      const j = await r.json(); if(!r.ok || !j.success) throw new Error(j.error||`HTTP ${r.status}`);
      show(`Crew ${teamCode} ${locked?'locked':'unlocked'}`,'ok');
    }catch(e){show('Failed to toggle lock: '+e.message,'err')}
  }

  /* =======================
     Stats / Messages
     ======================= */
  function updateStats(crews){
    const total = crews.length;
    const active = crews.filter(c=>(c.status||'active')==='active').length;
    const returned = crews.filter(c=>['returned','late'].includes(c.status)).length;
    const penalized = crews.filter(c=>(c.penalty||0)>0).length;
    document.getElementById('totalCrews').textContent=total;
    document.getElementById('activeCrews').textContent=active;
    document.getElementById('returnedCrews').textContent=returned;
    document.getElementById('penalizedCrews').textContent=penalized;
  }
  function show(text,type){
    const box=document.getElementById('messages');
    const el=document.createElement('div');
    el.className='msg '+(type==='err'?'err':'ok'); el.textContent=text;
    box.appendChild(el); setTimeout(()=>el.remove(),4500);
  }
</script>

</body>
</html>
